# 在一个拥挤变化的世界中茁壮成长：C++ 2006–2020

BJARNE STROUSTRUP, 摩根斯坦利，哥伦比亚大学，美国 

指导者：Yannis Smaragdakis，雅典大学，希腊  

到2006年，C++已经在工业界广泛传播了20年。它包含了自1970年代初引入C语言后没有变化的部分，以及在2000年代初的新特性。从2006年到2020年，C++开发者社区从300万左右增长到到450万左右。这段时间新的编程模型出现，硬件架构演变，新的应用领域变得非常重要，而且有一大批资金充足，营销专业的语言争夺主导地位。C++——一种古老的，没有严肃的商业支持的语言是怎么设法面对这一切，繁荣发展的呢？  

这篇论文包含了大量记录C++成长的特性列表，用简短的代码片段来讨论和解释重要的技术观点。此外，论文展现了一些被拒了的提案和导致这些提案被拒的讨论，提供了一个观察这些年来一些令人困惑的事实和特性的视角，重点在于想法，人和塑造语言的过程。  

论文主题包括了通过渐进性的变化来保持C++的本质，简化C++的使用，增强对泛型编程的支持，对编译期编程更好的支持，扩展对于并发，并行编程的支持，维护几十年老代码的稳定性的一系列努力。  

ISO C++标准是通过协商一致的过程演变的。不可避免地会有提案之间的竞争，方向，设计哲学和原则上的冲突（一般是礼貌的）。现在的委员会比以往人数更多，更加活跃，一年三次为期一周的会议会有250人参加，更多的人会参加电子会议。我们试图（并不总是成功）地减轻来自委员会设计的影响，官僚主义的尸位素餐，和对流行的语言特性的过度热情。  

具体的语言技术主题包括了内存模型，并发并行，编译期计算，移动语义，异常，lambda表达式和模块。设计一种足够灵活而精确的指定模板参数满足的要求的机制，还不增加运行时的开销是困难的。反复尝试设计“concept”去满足之前的要求，来源于1980年代，并且触碰到了很多关键的C++和泛型编程的设计问题。  

这段描述是在ISO C++标准委员会档案中的数千份文件和数百份会议记录的支持下，基于个人参与的关键事件和设计决策。

CCS分类：**软件及其工程**&rarr;**软件符号和工具**；**泛型编程语言**  

附加关键词和短语：C++，编程语言的设计和演变，标准化，泛型编程，资源管理，并发和并行，语言使用的简化。  

**ACM引用格式**：Bjarne Stroustrup. 2020. Thriving in a Crowded and Changing World: C++ 2006ś2020. Proc. ACM Program.Lang. 4, HOPL, Article 70 (June 2020), 167 pages. [https://doi.org/10.1145/3386320](https://doi.org/10.1145/3386320)  

## 1 介绍

最初，我设计 C++ 的目的是回答这个问题：“如何能够直接操纵硬件同时支持高效的高层次抽象？”这些年来，C++ 已经从一个较为简单的、基于 C 和 Simula 一系列设施组合的、专注于在八十年代计算机上的系统编程的解决方案，成长为一个远比之前复杂而有效的工具，适用于极其广泛的一系列应用。它仍然保留着其两方面的关注点：

- _从语言结构到硬件设备的直接映射_
- _零成本抽象_

这个组合是将 C++ 与其他语言区分开来的决定性特征。

[[Stroustrup 1994]()] 这样解释“零成本”：

- _对于不使用的功能，你无需付出代价（又称“没有分发的脂肪”）。_
- _对于要使用的功能，你无法手写得更好。_

抽象在代码中表现为函数，类，模板，概念，以及别名。

C++ 是一门活的语言，所以它为应对新的挑战而改变，而其使用风格也在进化。在 2006 至 2020 时间段的这些挑战和变化即为本文的关注点。当然，一门语言自己不会改变，而是由人来改变。所以这篇文章也是参与 C++ 的进化的人的故事，即他们发觉 C++ 面对的挑战，翻译解决方案上的限制，组织其工作，以及解决他们之间不可避免的差异的方式。我写这篇文章的背景环境，是 C++ 的总体进化和当时参与其中的每个人的顾虑。对于很多在早期被接受的功能，我们现在已从工业中的大规模使用获得了好处的实证。

C++ 主要是一门工业语言，是构建系统的工具。对于用户来说，“C++”不只是一门由规范定义的语言，而是由众多部件组成的工具集的一部分：

- 语言
- 标准库
- 许多其他库
- 巨大——通常古老——的代码库
- 工具（包括其他语言）
- 教学与训练
- 社区支持

我将在可能并且有关的时候，考虑这些“部件”之间的交互。

非常受欢迎的一个说法是：程序员希望他们的语言是简单的。显然，当你要学习一门新语言、设计语言课程、或者在论文中描述一门语言的时候是这样的。对于这些用途，使一门语言干净地体现几条简洁的原则，是明显的优势，也是理想情况。当关注点从学习移至交付并维护重要应用的时候，程序员的需求便从简洁变为完善的支持、稳定性（兼容性）、以及熟悉程度。人们一成不变地将熟悉误认为简洁，并在有选择的情况下倾向熟悉。

看待 C++ 的方式之一，是视之为三个矛盾的需求经历数十年的结果：

- 把语言做的更简单一些！
- 马上加入这两个必不可少的功能！！
- 不要让我的（任何）代码不能工作！！！

我加了感叹号，因为人们通常带着相当的情绪提出这些要点。

我想把简单的东西做简单，也想保证复杂的东西不会过分困难甚至不可能。前一部分对于不是语言律师的开发者来说是必不可少的，而后一部分则是为了基础代码的实现者。对于所有需要持续存在数十年的系统来说，稳定性是其必不可少的属性，但是一门活的语言必须适应不断变化的世界。

这些是对 C++ 理念的勾画。我明确表述了其中一些（例如_C++ 的设计与进化_[[Stroustrup 1994]()] （§2 、设计原则（§[9.1]()）及 C++ 模型（§[11.1]()）），并尝试使语言的进化跟随它们。然而长篇的新特性与非常详细的实践顾虑是 ISO 标准委员会控制下的 C++ 发展的主要焦点。社区中声音和影响力最大的人就关注这些，而仅基于哲学或理论视角，就认定他们的顾虑和观点是错的，这种做法是莽撞的。

### 1.1 年表

此处给出粗略的年表作为概述。如果您不熟悉 C++，许多术语、构造、以及库会显晦涩；大多数在之前的 HOPL 文章 [[Stroustrup 1993](), [2007]()] 以及本文中有详细介绍。

- 1979：开始着手构建“带有类的 C”，后来演变为 C++；第一位不是研究者的用户；
	- 语言：**类**，构造/析构函数，**公有/私有成员**，简单的继承，函数参数类型检查
	- 库：**任务**（协程和对仿真的支持），用宏参数化的 **vector**
- 1985：第一版商业化发布的 C++；TC++PL1 [[Stroustrup 1985b]()]
	- 语言：**虚函数**，运算符重载，引用，**const**
	- 库：**复数运算**，流式输入输出
- 1989-91：开始 ANSI 与 ISO 标准化；TC++PL2 [[Stroustrup 1991]()]
	- 语言：抽象类，多继承，异常，模板
	- 库：iostream （但是没有**任务**）
- 1998：第一个 ISO C++ 标准 C++98 [[Koenig 1998]()], TC++PL3 [[Stroustrup 1997]()]
	- 语言：**命名空间**，具名的转型运算符，**bool**，**dynamic_cast**
	- 库：标准库（容器与算法），**string**，**bitset**
- 2011：C++11 [[Becker 2011]()]，TC++PL4 [[Stroustrup 2013]()]
	- 语言：内存模型，**auto**，范围 **for**，**constexpr**，lambda 表达式，用户定义字面量，……
	- 库：**线程**和锁，**future**，**unique_ptr**，**shared_ptr**，**array**，时间和时钟，随机数，无序容器（散列表），……
- 2014：C++14 [[du Toit 2014]()]
	- 语言：泛型 lambda ，**constexpr** 函数中的局部变量，数字分隔符，……
	- 库：用户定义字面量，……
- 2017：C++17 [[Smith 2017]()]
	- 语言：结构化绑定，变量模板（译注： BS 原文有误，变量模板是在 C++14 加入的），从构造函数推断模板实参，……
	- 库：文件系统，**scoped_lock**，**shared_mutex**（读写锁），**any**，**variant**，**optional**，**string_view**，并行算法，……
- 2020：C++20 [[Smith 2020]()]
	- 语言：**概念**，**模块**，协程，三路比较，增强的编译期运算支持，……
	- 库：概念，范围，日期和时区，**span**，格式化，增强的并发与并行支持，……

注意早年间库的匮乏。当时实际有许多库（包括图形用户界面库），但是很少得到广泛使用，并且许多有专利。这是在开源盛行之前的情况。这种情况使得 C++ 社区缺少重要的共用基本库。在我的 HOPL2 文章 [[Stroustrup 1993]】)] 的回顾中，我认为这是早期 C++ 犯下的最糟糕的错误。

任务库 [[Stroustrup 1985a,c]()] 是一个基于协程的库，带有一些事件驱动仿真（例如随机数生成）的支持，它与替代品相比，即使是在微型计算机上也非常高效。譬如我曾在 256KB 内存上仿真了 700 个任务。任务库身为贝尔实验室和其他地方的许多重要应用的基础,在 C++ 早期无比重要。然而，它有一点丑陋，并且无法轻易地移植到 Sun 的 SPARC 架构，所以大多数 1989 后的实现都不支持它。 2020 年，协程也只是刚回来（§9.3.2）。

基本上，特性的集合的发展是连续的。 ISO 委员会弃用了少数特性以试图清理语言，但对于大量的 C++ 使用（“数百万行代码”），没有重要特性离开过。稳定性是一个关键特性。指出与增长的大小和复杂度相关的问题的方法之一，是通过编码方针（§10.6）。

### 1.2 总览

此文大致根据一系列 ISO 标准发布的时间顺序组织。

- §[1]()：介绍
- §[2]()：背景：C++ 1979-2006
- §[3]()：C++ 标准委员会
- §[4]()：C++11：像是一门新语言
- §[5]()：C++14：补全 C++11
- §[6]()：概念
- §[7]()：错误处理
- §[8]()：C++17：迷失于海
- §[9]()：C++20：方向斗争
- §[10]()：2020 年的 C++
- §[11]()：回顾

如果诸如“概念”与标准进程的专题横跨一段长时间的，我会将它于一处涵盖，与年表格式相比我优先于内容。

这篇文章长得出格，实为专著。然而，从 2006 至 2020 年，C++ 经历了 C++11 和 C++20 两个大版本，而且早期的读者都要求增加更多内容，这几乎使得文章的页数加倍。即使在当前的长度，读者也会发现一些重要的话题没有得到足够的讨论，例如并发和标准库。

## 2 背景: C++ 1979–2006 

C++在1979到2006年的历史被记录在我的HOPL论文[[Stroustrup 1993, 2007]()]中了。在那个时期，C++从一个单人研究项目发展成为了一个拥有300万开发者的社区。  

### 2.1第一个十年

以C with classes的名义最终成为C++的工作开始于1979年四月。我想要一个工具，既直接又高效和硬件交互（例如：写内存管理器，进程调度器，设备驱动），又有像Simula一样组织代码的设施（例如：“强”静态扩展类型检查，类，类层次和协程）。我希望这个工具能够编写一个可以在用于通过局域网或共享内存连接的多个处理器上工作的Unix内核的版本。  

我选择了C作为我工作的基础，因为它足够好，而且能就近获得很好的支持：我的办公室就在Dennis Ritchie 和 Brian Kernighan办公室走廊对面。然而，C并不是我考虑的唯一语言。我被Alogol68深深吸引，并且在那个时候我在BCPL和几门其他的机器级上非常专业。在那个时候，C后来的成功还没能确定。但是Brian Kernighan and Dennis Ritchie的非常棒的介绍和手册[[Kernighan and Ritchie 1978]()]刚刚出现而且Unix开始了它的胜利之旅。  

最初的实现是一个能或多或少一行行地把“C with Classes”翻译成C的预处理器。在1982年，随着“C with Classes”的用户增长到几十人，这种方法被证明是不可控的。所以我写了一个常规的编译器，叫Cfront，这个编译器在1983年十月第一次被其他人使用。Cfront是一个传统的编译器因为它有一个词法分析器，一个构建AST的语法分析器，一个用类型修饰AST的类型检查器，一个重构了AST以增加了生成代码的运行时效率的高等优化器。关于Cfront的性质，有很多混乱的地方，因为它最终输出的是C（优化过的，而非特别可读的C）。我生成了C，因此我不必直接处理当前使用中无数（非标准化的）的连接器和优化器。不过Cfont并不像传统的预处理器。 你可以在计算机历史博物馆的源代码集合中找到一个带有文档的Cfront源代码[[McJones 2007-2020]()]。Cfront从C with Classes到C++都是自举的，因此第一个C++编译器是用（简单的）C++为微型计算机（内存小于1MB，处理器速度小于1MHz）编写的。  

第一个作为“C with Classes”被添加进C的特性是类。我从早期使用Simula的使用中了解了它的威力，在Simula中它是严格静态但是可扩展的类型系统的关键。我立刻添加了构造函数和析构函数。这两个特性很新，但是从我的机器架构和操作系统的背景来看，我认为建立一个工作环境（构造函数）和一个在运行时释放已经获取的资源的逆操作（析构函数）是显然的。1979年我的实验手册上写道：  

- _“new函数”为成员函数创建了运行时环境_  
- _“delete函数”是其逆操作_  

“new函数”和“delete函数”这两个术语就是“构造函数”和“析构函数”的原始版本术语。直到今天，我还是认为构造函数和析构函数这一对是C++的真正核心。参阅(§[2.2.1]()) and (§[10.6]()).  

当时，基本除了C语言的所有语言都有像样的对函数参数的类型检查。我认为没有这个做不出什么有重大意义的事情。所以，在我的部门主管Alexander Fraser的鼓励下，我立刻添加了（可选的）函数参数声明和参数检查。这就是现在C里叫做函数原型的东西。人们想让他们的类型错误，至少有很多人大声说他们不想要检查并以此作为不使用C++的理由。这一事实可能会让人们了解发展一门语言在有意义的使用中的所涉及的问题。  

考虑到过度狭隘的C和C++的粉丝偶尔会互喷脏话，有一点或许值得指出：我和Dennis Ritchie 和Brian Kernighan一直是朋友，在16年中的大多数日子和他们共进午餐。我从他们那里学到了很多，现在还定期能看到Brian。我把对C++的贡献归功于两者[[Stroustrup 1993]()]，我本人也是C的主要贡献者（例如，函数定义语法，函数原型，const，和//注释）。  

为了能够理性考虑C++的发展，我设计了一套设计原则。这些原则载于[[Stroustrup 1993, 1994]()]，所以我在这里只提出一个小样本：  

- _不要为了完美参与到没有价值的探索中_  
- _永远提供一个过渡路径_  
- _表述出你的想法（即，能够直接表达更高层次的想法）_  
- _没有隐式违反静态类型系统_  
- _为用户定义类型提供和内置类型一样完善的支持_  
- _应该淘汰预处理器的使用_  
- _对低于C++的低级语言不留余地（除了汇编语言）_  

这些都是有野心的目标。在2020，我还在为了其中的某些而工作。在1980年代的早中期，我向C++添加了更多的语言设施：

- _1981_：**const**——支持接口中的不变性和符号常量。  
- _1982_：虚函数——提供运行时多态  
- _1984_：引用——支持运算符重载和简单的参数传递  
- _1984_：运算符重载——包括允许用户定义=（赋值），**()**（应用(译者注：语源std::apply)，使“函数对象”(§[4.3.1]())可用），**[]**（下标）和**->**（智能指针(译者注：pointer like types (来自 LFTSv2 )可能更全面)）除了算术和逻辑运算符。  
- _1987_：类型安全的连接——消除了来自很多分离的翻译单元中不一致的声明的错误。  
- _1987_：抽象类——提供了纯接口  

在1980年代后期，随着计算机性能的显著增加，我对更大规模软件的兴趣也在增加，并且增加了：  

- 模板——在受了多年用宏进行泛型编程之后，更好地支持泛型编程
- 异常——试图给错误处理的混乱局面带来一些秩序。RAII(§2.2.1)就是这项设计的明确表达。  

这些后来增加的特性并不是普遍受到欢迎的(例如，见§7)。一部分原因是因为社区变得庞大而无法管理。ANSI标准化已经开始所以我不能私下实现和实验了。在严肃实施之前，人们坚持进行大规模的详细设计和广泛辩论。在我知道不可能取悦所有人的时候，我不能再从一个最小的建议开始，把它发展成一个更完整的设施。举个例子，人们坚持使用“冗长的”模板语法，在每个地方带上**template<typename T>**前缀。  

在1980年代晚期，对“面向对象”的炒作甚嚣尘上，还从我这里窃取了一些关于C++的信息。我的关于C++是什么和C++注定要成为什么的评论被广泛地忽视了——很多人从来没有听说过。所有新语言都对于某种“面向对象”的定义是“纯面向对象”的。不是“真 OO ”被认定为坏而无需争议。  

我从没用过“C++是一门面向对象的语言”这句话的事情并不为人所知或者被忽视掉了，因为有点尴尬。那个时候，我的标准描述是：  

_C++是一门通用编程语言，偏向系统编程，并且_  

- _是更好的C_  
- _支持数据抽象_  
- _支持面对对象编程_  
- _支持泛型编程_  

这个描述过去是（现在也是）准确的，但是不像“万物皆对象”这种口号这么令人振奋。  

### 2.2第二个十年

ANSI ++委员会成立于1989年12月在华盛顿举行的一次会议上，仅仅在“C with Classes”第一次出现十年出头之后。大约25名C++程序员出席。
委员会经过了大约十年的墨守成规的工作，提出了它的第一个标准，C++98。当然，我和其他很多人更喜欢早一些的标准，但是委员会的规矩，雄心壮志和各种各样的延迟让我们和Fortran，C和其他正式标准化的语言的时间表保持了一致。  

C++98相关工作的核心是这篇HOPL3的论文[[Stroustrup 2007]()]，所以在这里我只简单总结一下：  

#### 2.2.1_语言特性_。C++98的核心语言特性如下：  

- 模板——无约束，图灵完备，具有很多阐述和改进，跟进我早期工作（§[2.1]()）的泛型编程的编译期支持。这项工作会继续进行（§[6]()）。 

- 异常——一种在要处理的单独(不可见)路径上返回错误值的机制，由代码“elsewhere”到调用者堆栈进行处理，见(§[7]())。  

- **dynamic_cast**和**typeid**——一种非常简单的运行时反射形式（“运行时类型识别”也叫作RTTI）。  

- **命名空间**——允许程序员在从部分的部分组成更大的程序时避免名称冲突。  

- 条件语句中的声明——使记法紧凑并限制变量的作用域。  

- 具名转换（**static_cast**，**reinterpret_cast**，和**const_cast**）——消除C风格转换的歧义并且使得显式类型转换更加明显。  

- **bool**——一种被证明是出乎意料地有用和流行的布尔类型。 C和C++过去使用整数作为布尔变量和常量。  

考虑一个简单的C++98的例子。**dynamic_cast**是面向对象语言中的“isKindOf”的C++版本： 

```c++ 
void do_something(Shape* p) 
{ 
    if(Circle* pc = dynamic_cast<Circle*>(p)) { // p是一个circle吗？
    	// ... 使用pc指向的Circle ... 
    } 
    else { 
    	// ... 它不是个circle，干点别的 ... 
    } 
}  
```

**dynamic_cast**是依赖储存在**Shape**的虚函数表中的数据的运行时操作。这很通用，易于使用，和其他语言的同样的语言设施一样高效。但是，**dynamic_cas**t变得相当不受欢迎，因为它的实现往往是很复杂的，在特殊情况下手工编写会更高效（所以可以说**dynamic_cast**违反了零开销的原则）。在条件中使用声明是很新奇的，尽管当时我认为我只是从Algol68中照抄了这个想法。  

一个更简单的使用引用代替指针的变体如下：  

```c++
void do_something2(Shape & r) 
{ 
    Circle& rc = dynamic_cast<Circle&>(r);  // r是种Circle
    // ... 使用rc引用的Circle ... 
}  
```

这段代码简单地断言了**r**指向了一个**Circle**，如果不是，则抛出换一个异常。这个想法是如果“错误”可以合理地被在原地被处理处理，使用指针和测试；如果不是，使用引用和异常。  

C++98中最重要的一项技术是RAII（_资源获得即初始化_）。这是我给每一项资源都应该有一个有作用域的对象的所有者这个想法起的笨拙的名字：构造函数获取资源，析构函数隐式地释放资源。这个想法出现在最早的C with Classes（§[2]()），但是直到十年后才被命名。这里是一个我经常用来阐述不是每项资源都是内存的想法的例子：  

```c++
void my_fct(const char* name)  // C风格资源管理
{ 
	FILE *p = fopen (name,"r");  // 为了读取打开文件name 
	// ... 使用p ... 
	fclose(p); 
}  
```

这里的问题是如果（在**fopen()**和**fclose()**中间）我们从函数中**返回**了，**抛出**了一个异常，或者使用了C的**longjmp**，这个**p**指向的文件句柄就泄露了。操作系统中文件句柄泄露甚至比内存泄漏还要快。那个文件句柄就是一个_非内存资源_的例子。  

解决方案是用一个含有构造函数和析构函数的类来代表文件句柄。  

```c++
class File_handle { 
    FILE * p; 
    public : 
    File_handle(const char* name , const char* permissions); // 打开文件
    ~ File_handle(); // 关闭文件
    // ... 
};  
```



现在我们可以简化我们的使用了：  

```c++
void my_fct2(const char* name)  // RAII风格的资源管理
{ 
	File_handle p( name ," r ");  // 为了读取打开文件name 
	// ... 使用p ... 
} // p被隐式地关闭了
```

随着异常的使用，这种资源句柄变得无处不在。特别地，标准哭的文件流就是这样一个资源句柄，所以使用C++98标准库，这个例子就变成了：  

```c++
void my_fct3(const string& name) 
{ 
    ifstream p(name);  // 为了读取打开文件name 
    // ... 使用p ... 
} // p被隐式地关闭了 
```

注意，RAII代码与传统的函数用法不同，它允许在库中一次性地定义“清理”，而不必为每次使用资源而由程序员记住并显式地编写。关键是正确和健壮的代码更简单，更短，并且至少和传统的代码一样高效。在接下来的二十年中，RAII渗透到C++库的方方面面。  

拥有非内存资源的含义是垃圾收集本身不足以进行资源管理。此外，RAII加上智能指针（§[4.2.4]()）消除了GC的大部分必要。参阅（§[10.6]()）。  

#### 2.2.2标准库组件，C++98标准库提供了：  

- STL——由Alexander Stepanov编写的创新的，通用的，优雅的，高效的容器，迭代器和算法的框架。  

- 萃取——用于有模板编程的编译期属性的集合

- **string**——持有和操作字符序列的类型。字符类型是默认为_char_的模板参数。

- **iostreams**——Jerry Schwartz和标准委员会对我1984年的用以处理各种各样的字符类型，本地化和缓冲策略的流库的详细阐述。

- **bitset**——持有和操作一系列比特位的集合的类型。

- **locales**——和文化习俗的详细框架，主要和I/O有关。

- **valarray**——具有可优化向量操作的数字数组，不幸的是，看起来它没有太多的用途。

- **auto_ptr**——早期代表了互斥所有权的指针；在C++11中，它被**shared_ptr**（共享所有权）和**unique_ptr**（代表互斥所有权）（§[4.2.4]()）取代了

STL框架到现在为止仍是标准库组件中最重要的。我认为公平地说，它——和它所开创的泛型编程技术拯救了C++这种活着的现代语言。像所有的C++98的设施一样，STL在其他地方被广泛地描述了（例如，[[Stroustrup 1997，2007]()]）所以这里我仅举一个简短的例子：

```c++  
void test(vector<string>& v, list<int>& lst) 
{ 
    vector<string>::iterator p 
    	= find_if(v.begin(), v.end(), Less_than<string>("falcon")); 
    if (p != v.end()) {  // p指向'falcon' 
    	// ... 使用 *p ... 
    } 
    else {  // 'falcon'未找到
    	// ... 
    } 
    list<int>::iterator q //译者注：原文是vector，应为笔误。 
    	= find_if(lst.begin(), lst.end(), Greater_than<int>(42)); 
    // ... 
} 
```



标准库算法**find_if**遍历序列（由**begin**/**end**对分隔）寻找一个令谓语为真的元素。这个算法在三个方面都是通用的。
顺序元素的储存方式（这里是**vector**和**list**）
元素的类型（这里是**string**和**int**）
用于确定何时元素被找到的谓词（这里是**Less_than**和**Greater_than**）
注意这里没有面对对象的技术，这是依赖模板的泛型编程，有的时候被称作_编译期多态_。
这里的记法仍然是原始的，但是从大概2017年开始，我可以使用**auto**（§[4.2.1]()），**ranges**（§[9.3.5]()）和**lambdas**（§[4.3.1]()）来简化那段代码：  

```c++
void test2 (vector<string>& v , list<int>& lst) 
{ 
    if (auto p = find_if (v,[](const string& s) { return s<"falcon"; })) { 
    	// ... 
    } 
    // ... 
    if (auto q = find_if (lst,[](int x) { return x>42; })) { 
    	// ... 
    } 
    // ...  
}
```

### 2.3 C++在2006年

在2006年，我和其他大多数ISO C++委员会成员都对有着丰富特性的C++0x标准寄予厚望。计划在2007年冻结特性，所以我们有一个合理的期望：C++0x会是C++08或者C++09.事实上，C++0x变成了C++11，这也引起了关于十六进制C++0xB的笑话。

在我2006年HOPL的论文[[Stroustrup 2007]()]中，我列举了39项提案并且预测前21项会进入C++0x。有趣的是，在我的名单上的前25个提案中，有24个进入了C++11。提案22-25，我将其列为“开发中，目的是2007年的投票”。出乎我意料的是——也是巨大的惊喜——它们都进入了。提案26-39中甚至没有一项进入了C++17。剩下的提案10，“concepts”，在经历了漫长而悲伤的故事之后，在C++20有了一个快乐的结尾(§[6]())。

我和许多其他人对C++0x的延迟感到沮丧，担心在面对更现代和有着更好的融资替代品时，一个未被改进C++可能无法作为一种活的语言生存下来。在2006年，Java的使用仍在正常，微软的C#得到了巨大的支持和营销。我在2006年的估计是C++的使用——第一次——在过去四年中有轻微的下降。很难得到真实数字，而且我最好的估计（下降7%）在误差范围内，但是有肯定的理由去担心。像Java和C#这种语言，都是基于一个假设——通常也会大声宣布——C++是没有生态位的：

- “底层的事项”可以由少量的C或者汇编程序来处理。

- “高层的事项”会在一个巨大的运行时支持的系统中用更安全，更小，有垃圾回收的语言更好，更便宜，更有效率地完成。

- 像Java和C#这样的托管语言，使用垃圾回收和一致的运行时范围检查，使得不太专业的程序员更加高产，技术娴熟的程序员不那么必要。

- 将编程语言深度集成到一个平台中，并得到集成工具集的支持，对于生产力和大型系统的构建至关重要。

显然，我和其他很多人并不同意，但是这些曾经是（现在也是）严肃的论点，（如果正确的话）会导致放弃C++。C++是基于和底层操作系统分离的编程语言的传统模型，并由许多独立的工具供应商支持。托管语言往往是专有的；只有一个庞大而富有的组织才能开发所需的基础设施和库。我和C++社区的其他很多人都更喜欢语言不收公司的控制；这也是我参加ISO标准工作的一个原因。

回想起来，2006年或许是C++的最低谷，但是重要的技术事件刚刚发生：历史上的第一次，大约2005年，单处理器（单核）的性能停止增长，能量效率（“每瓦特的性能”）成为了关键的指标（特别对于服务器群和手持设备来讲）。计算机的经济因素转向青睐更好的软件。 语言或编程技术的效率低下再也不能被硬件的进步所完全掩盖。现在，一个使用“利器”的技术娴熟的开发人员可以（在大约10年后再次）比弱小的程序员或因工具链中的开销而阻碍的程序员获得数量级差距的经济利益。即使到了今天，这些事实还没有在所有的教育和管理系统中发挥作用，但是现在有许多重要的任务需要花费时间来精心编写高性能代码，这会带来巨大的回报。

另一个转折点来自供应商试图通过定义标准接口来将他们最喜欢的语言强加给所有用户，比如说GUI，这只能通过用他们喜欢的——往往也是专有的——语言。例如谷歌在Android中使用Java，苹果在iOS上使用Objective-C，微软在Windows上使用C#。软件的供应商试图使用方言来避免这种绑定，例如Objective C++[[Objective C++ Wikipedia 2020]()]，或者C++/CLI[[ECMA International 2005]()]，但是生成的代码仍然是不可移植的。很多组织，例如Adobe，谷歌和微软，以用C++编写要求最严苛的应用的主要代码，然后用薄薄的接口层适配不同的平台（比如，Android，iOS，和Windows）。在2006年，这种趋势还不明显。

在便携式设备（特别是智能手机）上，能量效率和平台独立性的需求结合在一起。一个影响是，根据我2018年的最好的估计，C++程序员的数量自2006年以来增长了约50%，达到了约450万名开发者[[Kazakova，2015]()]。这是一年150000开发者的增长，一年4%增长了十年。

在2006年，很少有人发现重要的硬件趋势融入进了C++的固有优势中。相反，社区和标准委员会专注于新的语言特性和库，以提高C++的使用性，并提高热情。一些委员会成员，包括我，感觉到紧急而严重的必要去进行重大改进。其他人更多的注重稳定语言和改进实现。一个标准委员会两个团体都需要，但创新和退缩之间的持续拉锯战是紧张的根源。 与任何大型组织一样，维护现状和为当前用户服务的人具有组织上的优势。在_The C++ Programming Language(3rd)_[[Stroustrup 1997]()]，我引用了Niccolò Machiavelli关于这个话题的言论：

> _“没有什么比开创一个新秩序更难执行的了，也没有什么比开创一个新秩序更令人怀疑的成功了，也没有什么比开创一个新秩序要应对更多的危险了。因为改革者是所有从旧秩序中获利的人的敌人，而在那些将从新秩序中获利的人中，只有温和的捍卫者。”_

我的意见是C++需要重大改进才能很好地为社区服务。C++程序被大量的部署，但是新的项目往往选择了更流行的语言，并且一些成功的C++项目正在被用这些语言重写。例如，很多谷歌的大型应用，比如搜索，过去是（现在也是）基于他们的map-reduce框架[[Dean and Ghemawat 2004, 2008]()]。这是个C++程序。然而，由于它因为商业原因是专有的，人们仿造了它，但对于C++社区来说，很遗憾，开源的map-reduce框架（Hadoop）因为各种各样的原因，是用Java完成的。

转用其他语言进行开发的另一个重要的原因是使用模板提供接口的灵活性使得提供一个使用了所有C++特性的稳定ABI极其困难：你可以灵活，也可以提供稳定的二进制接口，但是同时做到两者超出了绝大多数组织的能力范围。我认为人们需要C，Java，C#等的C++程序接口是一个促成原因。对于C++来说，ABI稳定性是一个真正困难的问题，尤其是C++标准必须是平台独立的。

更让C++社区雪上加霜的是，到了2006年，随着纸质出版物的减少，记者追逐时尚和广告收入，绝大多数覆盖了C++的专业软件杂志都死了。Dr Dobbs又持续了几年（2009年2月停刊）。C++会议被并入了“面对对象”或者通用软件开发的会议，剥夺了C++社区亮相新发展的场所。书还在写，但是程序员读的书越来越少了（或者说至少买的书少得多，因为盗版越来越容易，因此统计数据也变得更不可信了），在线资源变得更加受欢迎了。

一个更加严重的问题是C++在教育中的作用正在急剧下降。C++不再是“新和受欢迎的”并且Java正在作为一门更简单，更强大的语言向大学直接推销。美国高中的计算机科学测试突然从C++变为了Java。在大学里，Java作为入门语言的使用急速增加。C++教学的质量也在下降，大多数课程选择C优先教学法，或者认为面向对象的程序严重依赖于类层次结构才是唯一正确的方法。这两种方法都最小化了C++的优势并且需要重度使用宏。标准库（依赖泛型编程(§[2.2]())）和RAII（依赖构造函数/析构函数对(§[2.2.1]()）经常被完全排除在基础课程之外，或者放到了“高级功能”部分中，这部分大多数学生从未接触到或者认为很可怕。教科书往往陷入了晦涩的细节。当然，也有例外，但是平均来说，展现给学生的C++远不如最佳工业实践。2005年，我接受了向大一学生学生教学编程的挑战。我调研了大约二十本最受欢迎的C++程序设计教科书，最终大声抱怨：

> _“如果那就是C++，我也不喜欢”_

在使用了一本获得好评的教科书教学了一年后，我改为只使用自己的笔记，并且在2008年出版了_Programming: Principles and Practice using C++_[[Stroustrup 2008a]()]，但是到了今天，很多C++教学还有1980年代那味儿。

尽管如此，C++的使用又开始增加了。我认为原因是基本的技术趋势又青睐C++，在十年结束的时候C++11的开始也有帮助。

Boost库和Boost组织很重要[[Boost 1998-2020]()]。在1998年，Beman Dawes,一个很有经验的开发者，也是WG21很有影响力的成员，开始了一个“C++库仓库网站” [[Dawes 1998]()] ，有着明确的目标：开发C++库去建立未来标准化可以借鉴的现有做法。在那之前，C++甚至没有一个库的公共仓库。Boost慢慢成长为了一个活跃的组织，有着对新库的同行评审和一年一度的会议。Boost库的应用变得非常广泛，其中最流行的库被纳入了标准（例如，**regex**(§[4.6]()), **thread**(§[4.1.2]()), **shared_ptr**(§[4.6]), **variant** (§[8.3]())和文件系统(§[8.6]())）。对于C++社区来说，Boost库比ISO标准班表早了十多年可用，但是被作为一种“初级标准”是很重要的。许多委员会成员，尤其是Dave Abrahams，Doug Gregor，Jaakko Järvi，Andrew Sutton，当然还有Beman Dawes，都和Boost有关。

到了2006年，C++在工业界已经不再新颖，令人兴奋了，但是也传播到了很多行业中。C++在其出生的电信行业的使用依然很强劲。从电信业，C++的使用也传播到了游戏（例如，Unreal，PlayStation，Xbox和Douglas Adam的“Starship Titanic”（译者注：原文是“Spaceship Titanic”，恐为笔误）），金融（例如，Morgan Stanley和Renaissance Technologies），微电子（例如，Intel和Mentor Graphics），电影（例如，Pixar和Maya），航天（例如，Lockheed-Martin和NASA）和其他很多行业。

就我个人而言，我特别喜欢C++在科学和工程中的广泛应用，如高能物理（例如，CERN、SLAC、FermiLab）、生物学（例如人类基因组项目），太空探索（例如火星漫游者和外太空通信网络)、医学和生物学(例如断层扫描、通用成像、人类基因组项目和监测设备）等等。

### 2.4其他语言

人们经常寻找其他编程语言对C++的直接的技术性影响。这些影响很少。一般来说，来自共同的祖先和共享的想法的影响不断涌现。扩展C++的决定性论点往往与在C++社区中观察到的问题有关。从一种流行的语言中直接借鉴是罕见的，也比人们想象的要难的多。大多数标准委员会成员精通很多语言，也会留意有用的设施，库和技术。

考虑2000年代对C++的一些真实和推测的影响：

- **auto**——从初始化器推断类型的能力。 这在现代语言中很受欢迎，但及其古老。 我不知道它是从哪里来的，但我在1983年实现了它，当时不认为它很新颖(§[4.2.1]())。

- **tuple**—— 许多语言，特别有函数式编程传统的语言都有元组，通常作为内置类型。C++标准库中的**tuple**和它的许多用法灵感都来源于此。**std::tuple**是来源于**boost::tuple**[[Boost 1998-2020]()] (§[4.3.4]())。
- **regex**——在C++11中添加进的标准库**regex**是从Unix和JavaScript中的设施复制的(通过与Boost进行了适当的确认）(§[4.6]())。

- 函数式编程——函数式编程的特点和C++的构造有很多明显的相似之处。大多不是简单的语言特性而是编程技术。STL收到了函数式编程的启发，并且在Scheme[[Stepanov 1986]()和Ada [[Musser and Stepanov 1987]()中首次尝试（不成功）

- **future**和**promise**——从MultiLisp途径其他Lisp方言(§[4.1.3]())。

- Range-**for**—— 它在许多语言中都有等价物，但一个直接的灵感是STL的序列(§[4.2.2]())。

- **variant**,**any**和**optional**——很明显受到了各种各样语言的启发。

- Lambdas——很明显，在函数式语言中Lambda表达式的使用是灵感的一部分。但是，在C++中，lambdas的根源也包括了用于追溯到 BCPL 的用作表达式的代码块，本地函数（由于被认为容易出错并且增加了复杂性，被C和C++多次拒绝），和（最重要的）函数对象(§[4.3.1]())。

- **final**和**override**——为了更加明确地管理类的层次结构并且在很多面对对象的语言中出现了。在C++的最早期，它们就被考虑过了——认为不必要。

- 三路比较运算符，<=>，受到了C的**strcmp**和其他各种语言，包括PERL，PHP，Python的运算符的启发(§[9.3.4]())。

- **await**—— 最初的C++协程(§[1.1]())受到了Simula的用法的启发，但作为一个库而不是作为一种语言特性提供，为几种不同的并发替代方法留出了空间。C++20的无栈协程的想法主要来自于F#(§[9.3.2]())

 即使一个特性以相当直接的方式从另一种语言中借鉴，它也会发生改变。一般来说，语法为适应C++会改变很多。当从一个有垃圾回收语言中借鉴的时候，需要用和原来不一样的方式解决C++中对象和对象引用的差异。经常会在“翻译到”C++的时候发现新用法。把“lambdas”引入C++的故事提供了大多数这些现象的例子(§[4.3.1]())。

 许多人想象我(和其他与C++有关的人)整天坐在一起，在一场复杂的争夺流行语言主导地位的战争中制定战略。事实上，我没花时间在这种事上。大多数时候，我不会考虑其他语言，除非我碰巧出于一般的技术兴趣学习一种语言，或者用一种语言完成一些工作。我所做的是与软件开发人员交谈，考虑人们使用C++时遇到的问题，并考虑在标准委员会中建议改进的大量事务。当然，我也写代码来体验问题，并测试改进的想法。问题是找时间冷静地考虑什么是根本，什么是时尚，什么会造成伤害。

同样，C++对其他语言的贡献也很难确定。通常，相似的特性是并行演化的或者有着共同的根源。考虑：

- 在Java和C#中的泛型，它们从其他语言建模了它们的泛型，但只有在C++大规模地演示了泛型编程的实用性之后，才采用C++语法并添加了泛型。

- 在Java，Python等中的dispose惯用法——这是你能用有垃圾收集的语言近似析构函数的最好方法。

- D编程语言中的编译期计算——我向Walter Bright解释了早期的constexpr设计。

- C++的基于构造函数和析构函数的对象生存期模型是Rust灵感的一部分。有趣的是，这些天，C++经常被指控从Rust那里借用了这样的想法。

- C借用了C++11的内存模型，函数声明和定义语法，声明作为语句，const，//注释，inline，和for循环中的初始化器。

- C++和其他语言的许多不同源于C++的析构函数。这使得有垃圾回收的语言难以直接从C++借鉴。